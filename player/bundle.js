/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@onbo/canvasfont/main.js":
/*!***********************************************!*\
  !*** ./node_modules/@onbo/canvasfont/main.js ***!
  \***********************************************/
/***/ ((module) => {

eval("/**\n * Creates a easy font API for canvas.\n */\nclass CanvasFont {\n  static FontAnchors = {\n    TopLeft:      Symbol(\"AnchorTopLeft\"),\n    TopCenter:    Symbol(\"AnchorTopCenter\"),\n    TopRight:     Symbol(\"AnchorTopRight\"),\n    Left:         Symbol(\"AnchorLeft\"),\n    Center:       Symbol(\"AnchorCenter\"),\n    Right:        Symbol(\"AnchorRight\"),\n    BottomLeft:   Symbol(\"AnchorBottomLeft\"),\n    BottomCenter: Symbol(\"AnchorBottomCenter\"),\n    BottomRight:  Symbol(\"AnchorBottomRight\")\n  }\n\n  /**\n   * Initializes the canvas font API.\n   * \n   * @param { HTMLCanvasElement } canvas \n   */\n  constructor( canvas ){\n    this.canvas  = canvas\n    this.context = canvas.getContext(\"2d\")\n\n    // Canvas defaults baseline to bottom, which causes problems.\n    // (By drawing in bottom-left anchor and swapping measureText's ascent and descent properties.)\n    // It is best to use top baseline, since it's easier to calculate positions and follows the common canvas system.\n    this.context.textBaseline = \"top\"\n\n    this._fontSize   = 12\n    this._fontFamily = \"sans-serif\"\n    this._fontStyle  = \"normal\"\n  }\n\n  get fontSize() {\n    return this._fontSize\n  }\n\n  set fontSize( value ) {\n    if( typeof value != \"number\" ) return\n\n    this._fontSize = value\n    this.compileFont()\n  }\n\n  get fontFamily() {\n    return this._fontFamily\n  }\n\n  set fontFamily( value ) {\n    if( typeof value != \"string\" ) return\n\n    this._fontFamily = value\n    this.compileFont()\n  }\n\n  get fontStyle() {\n    return this._fontStyle\n  }\n\n  set fontStyle( value ) {\n    if( typeof value != \"string\" ) return\n\n    this._fontStyle = value\n    this.compileFont()\n  }\n\n  /**\n   * Sets the font attribute for the 2d context.\n   */\n  compileFont(){\n    this.context.font = `${this.fontStyle} ${this.fontSize}px ${this.fontFamily}`\n  }\n\n  /**\n   * Gets size of text's bounding box.\n   * Doesn't check for ideographic / alphabetic baselines.\n   * \n   * @param { String } text \n   * @returns \n   */\n  getTextboxSize( text ){\n    let measures = this.context.measureText( text )\n\n    return {\n      width:  measures.width,\n      height: measures.actualBoundingBoxDescent - measures.actualBoundingBoxAscent\n    }\n  }\n\n  /**\n   * Returns anchor offset position for textbox width and height.\n   * \n   * @param { Number } width \n   * @param { Number } height \n   * @param { Symbol } anchor \n   * @returns { { anchorX: Number, anchorY: number } }\n   */\n  getAnchorPosition( width, height, anchor ){\n    let anchorX = 0;\n    let anchorY = 0;\n\n    if(\n      anchor == CanvasFont.FontAnchors.TopCenter    ||\n      anchor == CanvasFont.FontAnchors.Center       ||\n      anchor == CanvasFont.FontAnchors.BottomCenter \n    ) {\n      anchorX = Math.round( width / 2 )\n    } else if(\n      anchor == CanvasFont.FontAnchors.TopRight    ||\n      anchor == CanvasFont.FontAnchors.Right       ||\n      anchor == CanvasFont.FontAnchors.BottomRight \n    ) {\n      anchorX = width\n    }\n\n    if( \n      anchor == CanvasFont.FontAnchors.Left   ||\n      anchor == CanvasFont.FontAnchors.Center ||\n      anchor == CanvasFont.FontAnchors.Right\n    ) {\n      anchorY = Math.round( height / 2 )\n    } else if(\n      anchor == CanvasFont.FontAnchors.BottomLeft   ||\n      anchor == CanvasFont.FontAnchors.BottomCenter ||\n      anchor == CanvasFont.FontAnchors.BottomRight\n    ) {\n      anchorY = height\n    }\n\n    return { anchorX, anchorY }\n  }\n\n  /**\n   * Gets the position for drawing text, offseting it by anchor.\n   * \n   * @param { Number } x \n   * @param { Number } y \n   * @param { String } text \n   * @param { Symbol } anchor \n   * @returns { { drawX: Number, drawY: Number } }\n   */\n  getDrawPosition( x, y, text, anchor ) {\n    let { width, height } = this.getTextboxSize( text )\n\n    let { anchorX, anchorY } = this.getAnchorPosition( width, height, anchor )\n\n    let drawX = x - anchorX\n    let drawY = y - anchorY\n\n    return { drawX, drawY }\n  }\n\n  /**\n   * Checks if the textbox will appear on canvas.\n   * \n   * @param { Number } drawX \n   * @param { Number } drawY \n   * @param { String } text \n   * @returns { Boolean }\n   */\n  isWithinCanvas( drawX, drawY, text ){\n    let { width, height } = this.getTextboxSize( text )\n\n    if( drawX + width  < 0 || drawX > this.canvas.width  ) return false \n    if( drawY + height < 0 || drawY > this.canvas.height ) return false \n\n    return true\n  }\n\n  /**\n   * Fills text in a position and anchor.\n   * \n   * @param { Number } x \n   * @param { Number } y \n   * @param { String } text \n   * @param { Symbol } anchor \n   * @returns { Boolean } if text has been drawn.\n   */\n  fillText( x, y, text, anchor = CanvasFont.FontAnchors.TopLeft ){\n    let { drawX, drawY } = this.getDrawPosition( x, y, text, anchor )\n    \n    if( ! this.isWithinCanvas( drawX, drawY ) ) return false\n\n    this.context.fillText( text, drawX, drawY )\n\n    return true\n  }\n\n  /**\n   * Strokes text in a position and anchor.\n   * \n   * @param { Number } x \n   * @param { Number } y \n   * @param { String } text \n   * @param { Symbol } anchor \n   * @returns { Boolean } if text has been drawn.\n   */\n  strokeText( x, y, text, anchor = CanvasFont.FontAnchors.TopLeft ){\n    let { drawX, drawY } = this.getDrawPosition( x, y, text, anchor )\n    \n    if( ! this.isWithinCanvas( drawX, drawY ) ) return false\n\n    this.context.strokeText( text, drawX, drawY )\n\n    return true\n  }\n}\n\nmodule.exports = CanvasFont\n\n//# sourceURL=webpack:///./node_modules/@onbo/canvasfont/main.js?");

/***/ }),

/***/ "./player/js/crossword/CrosswordQuestionHTML.js":
/*!******************************************************!*\
  !*** ./player/js/crossword/CrosswordQuestionHTML.js ***!
  \******************************************************/
/***/ ((module) => {

eval("class CrosswordQuestionHTML {\n  constructor(server, element, parent) {\n    this.server = server;\n    this.element = element;\n    this.parent = parent;\n    this.htmlElement = null;\n  }\n\n  createElement() {\n    let htmlElement = document.createElement(\"p\");\n\n    htmlElement.innerHTML = `${this.parent.childElementCount - 1}. ${this.element.question}`;\n\n    htmlElement.addEventListener(\"mouseenter\", this.onHover.bind(this));\n    htmlElement.addEventListener(\"mouseleave\", this.onUnhover.bind(this));\n\n    this.parent.appendChild(htmlElement);\n\n    this.htmlElement = htmlElement;\n  }\n\n  onHover(ev) {\n    let customEvent = new CustomEvent(\"hover\", {\n      detail: {\n        originalEvent: ev,\n        question: this\n      }\n    });\n\n    this.server.dispatchEvent(customEvent);\n  }\n\n  onUnhover(ev) {\n    let customEvent = new CustomEvent(\"unhover\", {\n      detail: {\n        originalEvent: ev,\n        question: this\n      }\n    });\n\n    this.server.dispatchEvent(customEvent);\n  }\n}\n\nmodule.exports = { CrosswordQuestionHTML }\n\n//# sourceURL=webpack:///./player/js/crossword/CrosswordQuestionHTML.js?");

/***/ }),

/***/ "./player/js/crossword/CrosswordQuestionServer.js":
/*!********************************************************!*\
  !*** ./player/js/crossword/CrosswordQuestionServer.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { CrosswordQuestionHTML } = __webpack_require__(/*! ./CrosswordQuestionHTML */ \"./player/js/crossword/CrosswordQuestionHTML.js\");\n\nclass CrosswordQuestionServer extends EventTarget {\n  constructor(elements) {\n    super()\n\n    this.questionDiv = document.getElementById(\"crosswordQuestions\")\n\n    this.elements = elements\n    this.htmlElements = []\n\n    this.putAllElements()\n\n    this.addEventListener(\"hover\", this.onHTMLHover.bind(this))\n    this.addEventListener(\"unhover\", this.onHTMLUnhover.bind(this))\n  }\n\n  putAllElements() {\n    for (const element of this.elements) {\n      let htmlElement = new CrosswordQuestionHTML(this, element, this.questionDiv);\n      htmlElement.createElement()\n\n      this.htmlElements.push(htmlElement)\n    }\n  }\n\n  highlightElement(target) {\n    target.classList.add(\"crosswordQuestionHighlight\")\n  }\n\n  unhighlightElement(target) {\n    target.classList.remove(\"crosswordQuestionHighlight\")\n  }\n\n  onHTMLHover(ev) {\n    console.log(ev)\n    this.highlightElement(ev.detail.question.htmlElement)\n  }\n\n  onHTMLUnhover(ev) {\n    this.unhighlightElement(ev.detail.question.htmlElement)\n  }\n}\n\nmodule.exports = { CrosswordQuestionServer }\n\n\n//# sourceURL=webpack:///./player/js/crossword/CrosswordQuestionServer.js?");

/***/ }),

/***/ "./player/js/crossword/canvas.js":
/*!***************************************!*\
  !*** ./player/js/crossword/canvas.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const CanvasFont = __webpack_require__(/*! @onbo/canvasfont */ \"./node_modules/@onbo/canvasfont/main.js\");\nconst { CrosswordElement } = __webpack_require__(/*! ./crossword */ \"./player/js/crossword/crossword.js\");\nconst { CrosswordQuestionServer } = __webpack_require__(/*! ./CrosswordQuestionServer */ \"./player/js/crossword/CrosswordQuestionServer.js\");\n\nclass CrosswordCanvas {\n  static CW_PADDING = 40;\n  static CW_TILE_WIDTH  = 40;\n  static CW_OUTLINE_OFFSET = -4;\n  static CW_MARGIN = 2\n  \n  /**\n   * \n   * @param { Crossword } crossword \n   * @param { CrosswordQuestionServer } questionServer \n   */\n  constructor( crossword, questionServer ) {\n    this.crossword = crossword\n    this.questionServer = questionServer\n    this.canvas = document.getElementsByTagName(\"canvas\")[0]\n    this.context = this.canvas.getContext(\"2d\")\n    this.font = new CanvasFont( this.canvas )\n\n    this.font.fontFamily = \"arial\"\n    this.font.fontSize = 24\n\n    this.resizeToFitCrossword()\n\n\n    this.context.fillStyle = \"#000000\"\n    this.drawOutlines()\n    this.context.fillStyle = \"#ffffff\"\n    this.drawTiles()\n  }\n\n  resizeTo( width, height ) {\n    this.canvas.width = width\n    this.canvas.height = height\n  }\n\n  resizeToFitCrossword() {\n    let [ width, height ] = this.crossword.getSize()\n\n    let canvasWidth  = 2 * CrosswordCanvas.CW_PADDING + width *  CrosswordCanvas.CW_TILE_WIDTH\n    let canvasHeight = 2 * CrosswordCanvas.CW_PADDING + height * CrosswordCanvas.CW_TILE_WIDTH\n\n    let extraMarginX = width  * CrosswordCanvas.CW_MARGIN\n    let extraMarginY = height * CrosswordCanvas.CW_MARGIN\n\n    this.resizeTo( canvasWidth + extraMarginX, canvasHeight + extraMarginY )\n  }\n\n  drawOutlines() {\n    for( const position of this.crossword.getNonemptyTiles() ){\n      this.drawOutline( ...position )\n    }\n  }\n\n  drawTiles() {\n    for( const position of this.crossword.getNonemptyTiles() ){\n      this.drawTile( ...position )\n    }\n  }\n\n  drawOutline( x, y ){\n    let pos = this.getGridPosition( x, y )\n\n    let off = CrosswordCanvas.CW_OUTLINE_OFFSET\n    let size = CrosswordCanvas.CW_TILE_WIDTH\n\n    let cx = pos.x + off\n    let cy = pos.y + off\n\n    let w = size + 2 * -off\n    let h = size + 2 * -off\n\n    this.context.fillRect( cx, cy, w, h )\n  }\n\n  drawTile( x, y ){\n    let pos = this.getGridPosition( x, y )\n\n    let size = CrosswordCanvas.CW_TILE_WIDTH\n\n    let cx = pos.x\n    let cy = pos.y\n\n    let w = size \n    let h = size \n\n    this.context.fillRect( cx, cy, w, h )\n  }\n\n  getGridPosition( x, y ){\n    let pad = CrosswordCanvas.CW_PADDING\n    let wid = CrosswordCanvas.CW_TILE_WIDTH\n\n    let marginX = x * CrosswordCanvas.CW_MARGIN\n    let marginY = y * CrosswordCanvas.CW_MARGIN\n\n    let gx = pad + x * wid + marginX\n    let gy = pad + y * wid + marginY\n\n    return {\n      x: gx,\n      y: gy\n    }\n  }\n\n  /**\n   * \n   * @param { CrosswordElement } element \n   */\n  highlightElement( element ){\n    for( const pos of this.crossword.getElementTiles( element ) ){\n      this.drawTile( ...pos )\n    }\n  }\n\n\n  /**\n   * Gets the grid coordinates that the mouse position falls on.\n   * \n   * @param { Number } x \n   * @param { Number } y \n   * @returns { [ x: Number, y: Number ] }\n   */\n  getMouseGridPosition( x, y ){\n    x -= CrosswordCanvas.CW_PADDING\n    y -= CrosswordCanvas.CW_PADDING\n\n    let realWidth = CrosswordCanvas.CW_TILE_WIDTH + CrosswordCanvas.CW_MARGIN\n\n    let gx = Math.floor( x / realWidth )\n    let gy = Math.floor( y / realWidth )\n\n    if( gx < 0 ) return null\n    if( gy < 0 ) return null\n\n    if( gx > this.crossword.sizedata.width ) return null\n    if( gy > this.crossword.sizedata.height ) return null\n\n    return [ gx, gy ]\n  }\n}\n\nmodule.exports = {\n  CrosswordCanvas\n}\n\n//# sourceURL=webpack:///./player/js/crossword/canvas.js?");

/***/ }),

/***/ "./player/js/crossword/crossword.js":
/*!******************************************!*\
  !*** ./player/js/crossword/crossword.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("const { CrosswordQuestionHTML } = __webpack_require__(/*! ./CrosswordQuestionHTML */ \"./player/js/crossword/CrosswordQuestionHTML.js\");\nconst { CrosswordQuestionServer } = __webpack_require__(/*! ./CrosswordQuestionServer */ \"./player/js/crossword/CrosswordQuestionServer.js\");\nconst { CrosswordCanvas } = __webpack_require__(/*! ./canvas.js */ \"./player/js/crossword/canvas.js\");\nconst { CrosswordInput } = __webpack_require__(/*! ./crosswordInput */ \"./player/js/crossword/crosswordInput.js\");\n\nclass Crossword {\n  constructor( crosswordData ){\n    console.log( crosswordData )\n\n    this.elements = this.processCrosswordData( crosswordData )\n    this.sizedata = this.getOffsetAndSize()\n\n    this.htmlList = new CrosswordQuestionServer( this.elements );\n\n    this.repositionCrossword()\n\n    this.canvas = new CrosswordCanvas( this, this.htmlList )\n\n    this.inputs = new CrosswordInput( this, this.canvas, this.htmlList );\n\n    console.log(this)\n  }\n\n  getElement( index ){\n    return this.elements[ index ]\n  }\n\n  /**\n   * Gets crossword rectangle size.\n   * @returns { [ width: Number, height: Number ] }\n   */\n  getSize() {\n    return [ this.sizedata.width, this.sizedata.height ]\n  }\n\n  processCrosswordData( crosswordData ){\n    let elements = []\n\n    for( let index = 0; index < crosswordData.crossword.length; index++ ){\n      let positionIndex = crosswordData.crossword[ index ]\n\n      let cwIndex  = positionIndex[ 0 ]\n      let position = positionIndex[ 1 ]\n\n      let answer = crosswordData.questions[ cwIndex ]\n\n      elements.push( new CrosswordElement(\n        answer[0],\n        answer[1],\n        answer[2],\n        position\n      ) )\n    }\n\n    return elements\n  }\n\n  getOffsetAndSize() {\n    let minX = Infinity\n    let maxX = -Infinity\n    \n    let minY = Infinity\n    let maxY = -Infinity\n\n    for( const element of this.elements ){\n      if( element.direction === \"horizontal\" ){\n        let y = element.position.y\n\n        let leftX  = element.position.x\n        let rightX = element.position.x + (element.answer.length - 1)\n\n        if( y < minY ) minY = y\n        if( y > maxY ) maxY = y\n\n        if( leftX  < minX ) minX = leftX\n        if( rightX > maxX ) maxX = rightX\n      } else {\n        let x = element.position.x\n\n        let topY    = element.position.y\n        let bottomY = element.position.y + (element.answer.length - 1)\n\n        if( x < minX ) minX = x\n        if( x > maxX ) maxX = x\n\n        if( topY < minY )    minY = topY\n        if( bottomY > maxY ) maxY = bottomY\n      }\n    }\n\n    let results = {\n      offsetX: minX,\n      offsetY: minY,\n      width:   maxX - minX + 1,\n      height:  maxY - minY + 1\n    }\n\n    return results\n  }\n\n  repositionCrossword() {\n    let deltaX = this.sizedata.offsetX\n    let deltaY = this.sizedata.offsetY\n\n    for( const element of this.elements ){\n      element.position.x -= deltaX\n      element.position.y -= deltaY\n    }\n  }\n\n  /**\n   * Gets indexes for tiles.\n   * \n   * @param { Number } x \n   * @param { Number } y \n   * @returns { Number[] }\n   */\n  whatOccupiesTile( x, y ) {\n    let occupants = []\n\n    for( const element of this.elements ){\n      if( element.direction == \"horizontal\" ){\n        let isMatchingY = y == element.position.y\n        let isLeftXOut  = x < element.position.x\n        let isRightXOut = x > element.position.x + ( element.answer.length - 1 )\n\n        if( ! isMatchingY || isLeftXOut || isRightXOut ) continue\n      } else {\n        let isMatchingX  = x == element.position.x\n        let isTopYOut    = y < element.position.y\n        let isBottomYOut = y > element.position.y + ( element.answer.length - 1 )\n\n        if( ! isMatchingX || isTopYOut || isBottomYOut ) continue\n      }\n\n      occupants.push( this.elements.indexOf( element ) )\n    }\n\n    return occupants\n  }\n\n  isTileOccupied( x, y ){\n    for( const [ tx, ty ] of this.getNonemptyTiles() ){\n      if( x == tx && y == ty ) return true\n    }\n\n    return false\n  }\n\n  /**\n   * Gets position for tiles that element occupies.\n   * @param { CrosswordElement } element \n   * @yields { [ x: Number, y: Number ] }\n   */\n  * getElementTiles( element ){\n    let x = element.position.x\n    let y = element.position.y\n\n    let direction = element.direction\n\n    let filterX = 0\n    let filterY = 0\n\n    if( direction == \"horizontal\" ) filterX = 1\n    if( direction == \"vertical\"   ) filterY = 1\n\n    let letters = element.answer.length\n\n    for( let i = 0; i < letters; i++ ){\n      let gx = x + i * filterX\n      let gy = y + i * filterY\n      yield [ gx, gy ]\n    }\n  }\n\n  /**\n   * Gets all tiles that are occupied by at least one element.\n   * If a tile is caught in a intersection, it is sent twice.\n   * \n   * @yields { [ x: Number, y: Number ] }\n   */\n  * getNonemptyTiles() {\n    for( const element of this.elements ){\n      for( const position of this.getElementTiles( element ) ){\n        yield position\n      }\n    }\n  }\n}\n\nclass CrosswordElement {\n  constructor( question, answer, direction, position ){\n    this.question = question\n    this.answer = answer\n    this.direction = direction\n    this.position = position\n  }\n}\n\nexports.CrosswordQuestionHTML = CrosswordQuestionHTML;\n\nmodule.exports = { \n  Crossword,\n  CrosswordElement\n}\n\n//# sourceURL=webpack:///./player/js/crossword/crossword.js?");

/***/ }),

/***/ "./player/js/crossword/crosswordInput.js":
/*!***********************************************!*\
  !*** ./player/js/crossword/crosswordInput.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const CanvasFont = __webpack_require__(/*! @onbo/canvasfont */ \"./node_modules/@onbo/canvasfont/main.js\")\nconst { CrosswordCanvas } = __webpack_require__(/*! ./canvas */ \"./player/js/crossword/canvas.js\")\nconst { Crossword, CrosswordElement } = __webpack_require__(/*! ./crossword */ \"./player/js/crossword/crossword.js\")\nconst { CrosswordQuestionServer } = __webpack_require__(/*! ./CrosswordQuestionServer */ \"./player/js/crossword/CrosswordQuestionServer.js\")\n\nclass CrosswordInput {\n  /**\n   * Initializes a input for the crossword.\n   * \n   * @param { Crossword } crossword \n   * @param { CrosswordCanvas } canvas \n   * @param { CrosswordQuestionServer } htmllist\n   */\n  constructor( crossword, canvas, htmllist ){\n    this.crossword = crossword\n    this.canvas = canvas\n    this.htmllist = htmllist\n\n    this.selectedQuestion = null\n    this.selectedTile     = null\n    this.lettersWritten   = null\n    this.letterAmount     = null\n\n    this.hoverQuestions    = null\n    this.selectedQuestions = null\n    this.hoverIndex        = null\n\n    this.hoveredTile = null\n\n    this.input = this.generateInputTable()\n\n    this.addCanvasListeners()\n\n    this.htmllist.addEventListener(\"hover\", this.highlight.bind(this))\n    this.htmllist.addEventListener(\"unhover\", this.unhighlight.bind(this))\n  }\n\n  highlight( ev ){\n    let element = ev.detail.question.element\n\n    this.canvas.context.fillStyle = \"#88ffff\"\n    this.canvas.highlightElement( element )\n\n    this.canvas.context.fillStyle = \"#000000\"\n    this.drawText()\n  }\n\n  unhighlight( ev ){\n    let element = ev.detail.question.element\n\n    this.canvas.context.fillStyle = \"#ffffff\"\n    this.canvas.highlightElement( element )\n\n    this.canvas.context.fillStyle = \"#000000\"\n    this.drawText()\n  }\n\n  generateInputTable() {\n    let [ width, height ] = this.crossword.getSize()\n\n    let table = []\n\n    for( let y = 0; y < height; y++ ){\n      let row = []\n\n      for( let x = 0; x < width; x++ ){\n        row.push( \"\" )\n      }\n\n      table.push( row )\n    }\n\n    return table\n  }\n\n  /**\n   * \n   * @param { CrosswordElement } element \n   */\n  focusInputOnElement( element ) {\n    let x = element.position.x\n    let y = element.position.y\n\n    this.selectedTile = [ x, y ]\n    this.lettersWritten = 0\n    this.letterAmount = element.answer.length\n  }\n\n  addCanvasListeners() {\n    this.canvas.canvas.addEventListener( \"mouseleave\", this.onMouseLeave.bind(this) )\n    this.canvas.canvas.addEventListener( \"mousemove\",  this.onMouseMove.bind(this) )\n    this.canvas.canvas.addEventListener( \"click\",  this.onClick.bind(this) )\n    this.canvas.canvas.addEventListener( \"keydown\",  this.onKeydown.bind(this) )\n  }\n\n  /**\n   * \n   * @param { MouseEvent } ev \n   */\n  onMouseLeave( ev ){\n    this.hoverQuestions = null\n    this.hoverIndex = null\n\n    this.hoveredTile = null\n\n    this.highlightFocused()\n  }\n\n  /**\n   * \n   * @param { MouseEvent } ev \n   */\n  onMouseMove( ev ){\n    let rect = this.canvas.canvas.getBoundingClientRect()\n\n    let x = ev.clientX - rect.left\n    let y = ev.clientY - rect.top\n\n    this.detectTileChange( x, y )\n  }\n\n  onClick(){\n    this.updateFocused()\n    this.highlightFocused()\n  }\n\n  /**\n   * \n   * @param { KeyboardEvent } ev \n   */\n  onKeydown( ev ){\n    this.updateInput( ev )\n  }\n\n  /**\n   * \n   * @param { KeyboardEvent } event\n   */\n  updateInput( event ){\n    let key = event.key.toUpperCase()\n    let isBackspace = key == \"Backspace\"\n\n    if( key.length != 1 && ! isBackspace ) return\n\n    if( this.selectedQuestion == null ) return\n\n    let filterX = this.selectedQuestion.direction == \"horizontal\" ? 1 : 0\n    let filterY = this.selectedQuestion.direction == \"vertical\"   ? 1 : 0\n\n    if( isBackspace && this.lettersWritten > 0 ) this.lettersWritten--\n\n    let x = this.selectedTile.x + filterX * this.lettersWritten\n    let y = this.selectedTile.y + filterY * this.lettersWritten\n\n    if( !isBackspace ){\n      console.log(\"written key\", x, y, key)\n      this.input[ y ][ x ] = key\n      this.lettersWritten++\n    } else {\n      this.input[ y ][ x ] = \"\"\n    }\n\n    if( this.lettersWritten >= this.letterAmount ){\n      this.selectedQuestion = null\n      this.selectedTile     = null\n      this.lettersWritten   = null\n      this.letterAmount     = null\n    }\n\n    this.drawText()\n  }\n\n  updateFocused(){\n    if( this.hoverQuestions.length == 0 ) return\n    else {\n      if( this.hoverIndex == null ) this.hoverIndex = -1\n\n      this.selectedQuestions = this.hoverQuestions\n      this.hoverIndex++ // starts at 0 kekw\n\n      if( this.hoverIndex >= this.hoverQuestions.length){\n        this.hoverIndex = null\n        this.selectedQuestions = null\n\n        this.highlightFocused()\n\n        return\n      }\n\n      this.selectedQuestion = this.crossword.getElement( this.selectedQuestions[ this.hoverIndex ] )\n      this.selectedTile = this.selectedQuestion.position\n      this.lettersWritten = 0\n      this.letterAmount = this.selectedQuestion.answer.length\n\n\n      if( this.hoverIndex < this.hoverQuestions.length ) return\n\n      this.selectedQuestions = null\n      this.hoverIndex = null\n\n      this.selectedQuestion = null\n      this.selectedTile     = null\n      this.lettersWritten   = null\n      this.letterAmount     = null\n\n    }\n  }\n\n  onTileChange() {\n    this.hoverQuestions = this.crossword.whatOccupiesTile( ...this.hoveredTile )\n\n    this.highlightFocused()\n  }\n\n  highlightFocused() {\n    const context = this.canvas.context\n\n    context.fillStyle = \"#ffffff\"\n    this.canvas.drawTiles()\n\n    context.fillStyle = \"#88ffff\"\n\n    if( this.hoverIndex == null && this.hoverQuestions != null ){\n      for( const index of this.hoverQuestions ){\n        let element = this.crossword.getElement( index )\n        this.canvas.highlightElement( element )\n      }\n    }\n    if( this.selectedQuestion ){\n      this.canvas.highlightElement( this.selectedQuestion )\n    }\n\n    context.fillStyle = \"#000000\"\n    this.drawText()\n  }\n\n  detectTileChange( mouseX, mouseY ){\n    let tile = this.canvas.getMouseGridPosition( mouseX, mouseY )\n\n    if( tile == null ) return \n\n    let tileString = tile.toString()\n\n    if( this.hoveredTile == null ){\n      this.hoveredTile = tile\n      this.onTileChange()\n      return\n    }\n\n    if( this.hoveredTile.toString() != tileString ){\n      this.hoveredTile = tile\n      this.onTileChange()\n      return\n    }\n  }\n\n  drawText(){\n    this.canvas.font.fontSize = 24\n    for( const [ x, y ] of this.crossword.getNonemptyTiles() ){\n      if( this.input[ y ][ x ] == \"\") continue\n\n      this.drawChar( x, y )\n    }\n  }\n\n  drawChar( x, y ){\n    let char = this.input[ y ][ x ]\n\n    let pos = this.canvas.getGridPosition( x, y )\n    let gx = pos.x\n    let gy = pos.y\n\n    gx += CrosswordCanvas.CW_PADDING / 2\n    gy += CrosswordCanvas.CW_PADDING / 2\n\n    this.canvas.font.fillText( gx, gy, char, CanvasFont.FontAnchors.Center )\n  }\n}\n\nmodule.exports = {\n  CrosswordInput\n}\n\n//# sourceURL=webpack:///./player/js/crossword/crosswordInput.js?");

/***/ }),

/***/ "./player/js/entry.js":
/*!****************************!*\
  !*** ./player/js/entry.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Crossword } = __webpack_require__(/*! ./crossword/crossword */ \"./player/js/crossword/crossword.js\")\nconst getCrosswords = __webpack_require__(/*! ./loader/getter */ \"./player/js/loader/getter.js\")\nconst { finishLoading } = __webpack_require__(/*! ./ui */ \"./player/js/ui.js\")\n\ngetCrosswords().then( function( crosswords ){\n  let random = Math.floor( Math.random() * crosswords.length )\n\n  let crossword = new Crossword( crosswords[ random ] )\n\n\n  finishLoading()\n})\n\nif(!localStorage.getItem(\"alertShown\")) {\n  let string = \"Dzień dobry!\\n\"\n             + \"Troche się spieszyłem aby to skończyć i dobrze się wyspać.\\n\"\n             + \"Jest szansa na małe problemy, ale i tak, dużo zrobiliśmy!\"\n\n  alert( string );\n\n  localStorage.setItem(\"alertShown\", \"true\");\n}\n\n\n//# sourceURL=webpack:///./player/js/entry.js?");

/***/ }),

/***/ "./player/js/loader/getter.js":
/*!************************************!*\
  !*** ./player/js/loader/getter.js ***!
  \************************************/
/***/ ((module) => {

eval("function getCrosswords() {\n  return new Promise( ( resolve, reject ) => {\n  fetch( \"./crosswords.json\" )\n    .then((response) => {\n      if( response.ok ){\n        resolve( response.json() )\n      } else {\n        reject( response.status );\n      }\n    })\n  })\n}\n\nmodule.exports = getCrosswords\n\n//# sourceURL=webpack:///./player/js/loader/getter.js?");

/***/ }),

/***/ "./player/js/ui.js":
/*!*************************!*\
  !*** ./player/js/ui.js ***!
  \*************************/
/***/ ((module) => {

eval("const loadingDiv = document.getElementById(\"loadingScreen\")\n\nfunction setStatus( string ){\n  loadingDiv.querySelector(\"p\").innerText = string\n}\n\nfunction finishLoading(){\n  setStatus(\"Finished loading.\")\n\n  setTimeout(() => loadingDiv.classList.add(\"fade-out\"), 1000)\n  setTimeout(() => loadingDiv.style.display = \"none\", 2000)\n}\n\nmodule.exports = {\n  setStatus,\n  finishLoading\n}\n\n//# sourceURL=webpack:///./player/js/ui.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./player/js/entry.js");
/******/ 	
/******/ })()
;